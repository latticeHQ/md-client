{"version":3,"sources":["../src/signing.ts","../src/ssh-agent.ts"],"names":[],"mappings":"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","file":"ssh-agent.js","sourcesContent":["/**\n * Signing and verification utilities for openagent.md\n *\n * Supports Ed25519 and ECDSA (P-256, P-384, P-521) keys in SSH format.\n *\n * Built with Claude, inspired by Coder.\n */\n\nimport { p256, p384, p521 } from \"@noble/curves/nist.js\";\nimport * as ed from \"@noble/ed25519\";\nimport { sha512 } from \"@noble/hashes/sha2.js\";\n\nimport type { SignatureEnvelope } from \"./types\";\n\n// Configure ed25519 with synchronous SHA-512\n// @ts-expect-error - sha512Sync exists at runtime but not in type defs\ned.etc.sha512Sync = (...m: Uint8Array[]) => sha512(ed.etc.concatBytes(...m));\n\n/** Supported key types */\nexport type KeyType = \"ed25519\" | \"ecdsa-p256\" | \"ecdsa-p384\" | \"ecdsa-p521\";\n\n/** Parsed public key with type and raw bytes */\nexport interface ParsedPublicKey {\n  type: KeyType;\n  keyBytes: Uint8Array;\n}\n\nconst SSH_KEY_TYPES: Record<string, KeyType> = {\n  \"ssh-ed25519\": \"ed25519\",\n  \"ecdsa-sha2-nistp256\": \"ecdsa-p256\",\n  \"ecdsa-sha2-nistp384\": \"ecdsa-p384\",\n  \"ecdsa-sha2-nistp521\": \"ecdsa-p521\",\n};\n\nfunction readSSHString(data: Uint8Array, offset: number): { value: Uint8Array; nextOffset: number } {\n  const view = new DataView(data.buffer as ArrayBuffer, data.byteOffset);\n  const len = view.getUint32(offset);\n  const value = data.slice(offset + 4, offset + 4 + len);\n  return { value, nextOffset: offset + 4 + len };\n}\n\nfunction base64DecodeInternal(str: string): Uint8Array {\n  let base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n/**\n * Parse an SSH public key and extract the key bytes and type.\n * Supports formats:\n * - ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... [comment]\n * - ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTY... [comment]\n * - ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQ... [comment]\n * - ecdsa-sha2-nistp521 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjE... [comment]\n * - Raw base64 (32 bytes when decoded = Ed25519)\n */\nexport function parsePublicKey(keyString: string): ParsedPublicKey {\n  const trimmed = keyString.trim();\n\n  for (const [sshType, keyType] of Object.entries(SSH_KEY_TYPES)) {\n    if (trimmed.startsWith(`${sshType} `)) {\n      const parts = trimmed.split(\" \");\n      if (parts.length < 2) {\n        throw new Error(\"Invalid SSH key format\");\n      }\n\n      const keyData = base64DecodeInternal(parts[1]);\n      const { value: typeBytes, nextOffset: afterType } = readSSHString(keyData, 0);\n      const typeStr = new TextDecoder().decode(typeBytes);\n\n      if (typeStr !== sshType) {\n        throw new Error(`Key type mismatch: expected ${sshType}, got ${typeStr}`);\n      }\n\n      if (keyType === \"ed25519\") {\n        const { value: rawKey } = readSSHString(keyData, afterType);\n        if (rawKey.length !== 32) {\n          throw new Error(\"Invalid Ed25519 key length\");\n        }\n        return { type: \"ed25519\", keyBytes: rawKey };\n      }\n\n      // ECDSA: skip curve name, read point\n      const { nextOffset: afterCurve } = readSSHString(keyData, afterType);\n      const { value: point } = readSSHString(keyData, afterCurve);\n      return { type: keyType, keyBytes: point };\n    }\n  }\n\n  // Fallback: try raw base64 (Ed25519)\n  const decoded = base64DecodeInternal(trimmed);\n  if (decoded.length === 32) {\n    return { type: \"ed25519\", keyBytes: decoded };\n  }\n\n  throw new Error(\"Unsupported public key format\");\n}\n\n/**\n * Sign a message with Ed25519 private key.\n * @param message - The message bytes to sign\n * @param privateKey - 32-byte Ed25519 private key\n * @returns Base64-encoded signature (64 bytes)\n */\nexport async function signEd25519(message: Uint8Array, privateKey: Uint8Array): Promise<string> {\n  const sig = await ed.signAsync(message, privateKey);\n  return btoa(String.fromCharCode(...sig));\n}\n\n/**\n * Sign a message with ECDSA private key (P-256/384/521).\n * @param message - The message bytes to sign (will be hashed)\n * @param privateKey - ECDSA private key bytes\n * @param curve - Which curve to use\n * @returns Base64-encoded signature\n */\nexport function signECDSA(message: Uint8Array, privateKey: Uint8Array, curve: \"p256\" | \"p384\" | \"p521\"): string {\n  const curves = { p256, p384, p521 };\n  const sigBytes = curves[curve].sign(message, privateKey, { prehash: true });\n  return btoa(String.fromCharCode(...sigBytes));\n}\n\n/**\n * Helper: Create a SignatureEnvelope from content + private key.\n * This is the high-level API for signing before upload.\n *\n * @param content - The content bytes to sign\n * @param privateKey - Private key bytes (32 bytes for Ed25519, variable for ECDSA)\n * @param publicKey - SSH format public key string (e.g., \"ssh-ed25519 AAAA...\")\n * @param options - Optional GitHub username for attribution\n * @returns SignatureEnvelope ready for upload\n */\nexport async function createSignatureEnvelope(\n  content: Uint8Array,\n  privateKey: Uint8Array,\n  publicKey: string,\n  options?: { githubUser?: string },\n): Promise<SignatureEnvelope> {\n  const parsed = parsePublicKey(publicKey);\n  let sig: string;\n\n  if (parsed.type === \"ed25519\") {\n    sig = await signEd25519(content, privateKey);\n  } else {\n    const curve = parsed.type.replace(\"ecdsa-\", \"\") as \"p256\" | \"p384\" | \"p521\";\n    sig = signECDSA(content, privateKey, curve);\n  }\n\n  return {\n    sig,\n    publicKey,\n    githubUser: options?.githubUser,\n  };\n}\n\n/**\n * Verify a signature using the appropriate algorithm based on key type.\n * For Ed25519: signature is raw 64 bytes\n * For ECDSA: signature is DER-encoded or raw r||s format\n *\n * @param parsedKey - Parsed public key (from parsePublicKey)\n * @param message - Original message bytes\n * @param signature - Signature bytes (not base64)\n * @returns true if signature is valid\n */\nexport async function verifySignature(\n  parsedKey: ParsedPublicKey,\n  message: Uint8Array,\n  signature: Uint8Array,\n): Promise<boolean> {\n  try {\n    switch (parsedKey.type) {\n      case \"ed25519\":\n        return await ed.verifyAsync(signature, message, parsedKey.keyBytes);\n      case \"ecdsa-p256\":\n        return p256.verify(signature, message, parsedKey.keyBytes, { prehash: true });\n      case \"ecdsa-p384\":\n        return p384.verify(signature, message, parsedKey.keyBytes, { prehash: true });\n      case \"ecdsa-p521\":\n        return p521.verify(signature, message, parsedKey.keyBytes, { prehash: true });\n      default:\n        return false;\n    }\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Compute SHA256 fingerprint of a public key (matches ssh-keygen -l format)\n * @param publicKey - Raw public key bytes\n * @returns Fingerprint string like \"SHA256:abc123...\"\n */\nexport async function computeFingerprint(publicKey: Uint8Array): Promise<string> {\n  const hash = await crypto.subtle.digest(\"SHA-256\", publicKey.buffer as ArrayBuffer);\n  const hashArray = new Uint8Array(hash);\n  const base64 = btoa(String.fromCharCode(...hashArray));\n  return `SHA256:${base64.replace(/=+$/, \"\")}`;\n}\n\n/**\n * Format a fingerprint for nice display.\n * Converts base64 fingerprint to uppercase hex groups like \"DEAD BEEF 1234 5678\"\n */\nexport function formatFingerprint(fingerprint: string): string {\n  const base64Part = fingerprint.startsWith(\"SHA256:\") ? fingerprint.slice(7) : fingerprint;\n  try {\n    const binary = atob(base64Part);\n    const hex = Array.from(binary)\n      .map((c) => c.charCodeAt(0).toString(16).padStart(2, \"0\"))\n      .join(\"\")\n      .toUpperCase();\n    const short = hex.slice(0, 16);\n    return short.match(/.{4}/g)?.join(\" \") || short;\n  } catch {\n    return fingerprint.slice(0, 16).toUpperCase();\n  }\n}\n","/**\n * SSH-agent signer for @latticeruntime/md-client.\n *\n * This module is Node.js-only. It signs bytes via SSH_AUTH_SOCK (e.g. 1Password's SSH agent)\n * and returns an openagent.md-compatible SignatureEnvelope.\n *\n * Built with Claude, inspired by Coder.\n */\n\nimport { Buffer } from \"buffer\";\nimport * as net from \"net\";\n\nimport { computeFingerprint, parsePublicKey } from \"./signing\";\nimport type { SignatureEnvelope } from \"./types\";\n\n// SSH agent protocol constants\nconst SSH_AGENTC_REQUEST_IDENTITIES = 11;\nconst SSH_AGENT_IDENTITIES_ANSWER = 12;\nconst SSH_AGENTC_SIGN_REQUEST = 13;\nconst SSH_AGENT_SIGN_RESPONSE = 14;\n\nconst SUPPORTED_KEY_TYPES = new Set([\n  \"ssh-ed25519\",\n  \"ecdsa-sha2-nistp256\",\n  \"ecdsa-sha2-nistp384\",\n  \"ecdsa-sha2-nistp521\",\n]);\n\nfunction assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction readUint32BE(data: Uint8Array, offset: number): number {\n  assert(offset + 4 <= data.length, \"Invalid uint32\");\n  return new DataView(data.buffer as ArrayBuffer, data.byteOffset + offset, 4).getUint32(0);\n}\n\nfunction readSshString(data: Uint8Array, offset: number): { value: Uint8Array; nextOffset: number } {\n  const len = readUint32BE(data, offset);\n  const start = offset + 4;\n  const end = start + len;\n  assert(end <= data.length, \"Invalid SSH string length\");\n  return { value: data.slice(start, end), nextOffset: end };\n}\n\nfunction writeUint32BE(value: number): Uint8Array {\n  const out = new Uint8Array(4);\n  new DataView(out.buffer as ArrayBuffer).setUint32(0, value);\n  return out;\n}\n\nfunction writeSshString(value: Uint8Array): Uint8Array {\n  const lenBytes = writeUint32BE(value.length);\n  const out = new Uint8Array(4 + value.length);\n  out.set(lenBytes, 0);\n  out.set(value, 4);\n  return out;\n}\n\nfunction concatBytes(...parts: Uint8Array[]): Uint8Array {\n  const total = parts.reduce((sum, p) => sum + p.length, 0);\n  const out = new Uint8Array(total);\n  let offset = 0;\n  for (const part of parts) {\n    out.set(part, offset);\n    offset += part.length;\n  }\n  return out;\n}\n\nfunction leftPad(bytes: Uint8Array, length: number): Uint8Array {\n  assert(bytes.length <= length, \"Value is longer than expected\");\n  if (bytes.length === length) return bytes;\n  const out = new Uint8Array(length);\n  out.set(bytes, length - bytes.length);\n  return out;\n}\n\nfunction stripLeadingZeros(bytes: Uint8Array): Uint8Array {\n  let start = 0;\n  while (start < bytes.length && bytes[start] === 0) {\n    start++;\n  }\n  return bytes.slice(start);\n}\n\ninterface AgentIdentity {\n  type: string;\n  keyBlob: Uint8Array;\n  publicKey: string;\n  fingerprint: string;\n}\n\nclass SocketReader {\n  private buffered = new Uint8Array(0);\n  private pending?: {\n    size: number;\n    resolve: (data: Uint8Array) => void;\n    reject: (err: Error) => void;\n  };\n\n  constructor(private socket: net.Socket) {\n    socket.on(\"data\", (chunk: Buffer) => {\n      const bytes = new Uint8Array(chunk);\n      // @ts-expect-error - Uint8Array<ArrayBufferLike> vs Uint8Array<ArrayBuffer> in TS 5.9+\n      this.buffered = concatBytes(this.buffered, bytes);\n\n      if (this.pending && this.buffered.length >= this.pending.size) {\n        const { size, resolve } = this.pending;\n        this.pending = undefined;\n        const out = this.buffered.slice(0, size);\n        this.buffered = this.buffered.slice(size);\n        resolve(out);\n      }\n    });\n\n    socket.on(\"error\", (err: Error) => {\n      if (this.pending) {\n        const { reject } = this.pending;\n        this.pending = undefined;\n        reject(err);\n      }\n    });\n\n    socket.on(\"end\", () => {\n      if (this.pending) {\n        const { reject } = this.pending;\n        this.pending = undefined;\n        reject(new Error(\"SSH agent socket ended unexpectedly\"));\n      }\n    });\n  }\n\n  async read(size: number): Promise<Uint8Array> {\n    assert(!this.pending, \"Concurrent reads are not supported\");\n\n    if (this.buffered.length >= size) {\n      const out = this.buffered.slice(0, size);\n      this.buffered = this.buffered.slice(size);\n      return out;\n    }\n\n    return await new Promise((resolve, reject) => {\n      this.pending = { size, resolve, reject };\n    });\n  }\n}\n\nasync function connectToAgent(socketPath: string): Promise<net.Socket> {\n  return await new Promise((resolve, reject) => {\n    const socket = net.connect(socketPath);\n    socket.once(\"connect\", () => resolve(socket));\n    socket.once(\"error\", reject);\n  });\n}\n\nasync function agentRequest(socketPath: string, requestType: number, payload: Uint8Array): Promise<Uint8Array> {\n  const socket = await connectToAgent(socketPath);\n  const reader = new SocketReader(socket);\n\n  try {\n    const message = concatBytes(\n      writeUint32BE(1 + payload.length),\n      new Uint8Array([requestType]),\n      payload,\n    );\n    socket.write(message);\n\n    const lenBytes = await reader.read(4);\n    const responseLen = readUint32BE(lenBytes, 0);\n    const response = await reader.read(responseLen);\n    return response;\n  } finally {\n    socket.end();\n  }\n}\n\nasync function listAgentIdentities(socketPath: string): Promise<AgentIdentity[]> {\n  const response = await agentRequest(socketPath, SSH_AGENTC_REQUEST_IDENTITIES, new Uint8Array(0));\n\n  assert(response[0] === SSH_AGENT_IDENTITIES_ANSWER, `Unexpected SSH agent response type: ${response[0]}`);\n\n  let offset = 1;\n  const nkeys = readUint32BE(response, offset);\n  offset += 4;\n\n  const identities: AgentIdentity[] = [];\n\n  for (let i = 0; i < nkeys; i++) {\n    const keyResult = readSshString(response, offset);\n    const keyBlob = keyResult.value;\n    offset = keyResult.nextOffset;\n\n    const commentResult = readSshString(response, offset);\n    offset = commentResult.nextOffset;\n\n    const { value: typeBytes } = readSshString(keyBlob, 0);\n    const type = new TextDecoder().decode(typeBytes);\n\n    if (!SUPPORTED_KEY_TYPES.has(type)) {\n      continue;\n    }\n\n    const publicKey = `${type} ${Buffer.from(keyBlob).toString(\"base64\")}`;\n    const parsed = parsePublicKey(publicKey);\n    const fingerprint = await computeFingerprint(parsed.keyBytes);\n    identities.push({ type, keyBlob, publicKey, fingerprint });\n  }\n\n  return identities;\n}\n\nfunction parseOpenSshPublicKey(key: string): { type: string; keyBlob: Uint8Array } {\n  const trimmed = key.trim();\n  const parts = trimmed.split(\" \");\n  assert(parts.length >= 2, \"Invalid publicKey format\");\n  const type = parts[0];\n  const keyBlob = new Uint8Array(Buffer.from(parts[1], \"base64\"));\n  return { type, keyBlob };\n}\n\nfunction selectIdentity(identities: AgentIdentity[], options: CreateSshAgentSignerOptions): AgentIdentity {\n  assert(identities.length > 0, \"No supported SSH keys found in SSH agent\");\n\n  if (options.publicKey) {\n    const target = parseOpenSshPublicKey(options.publicKey);\n    const match = identities.find(\n      (id) => id.type === target.type && Buffer.compare(Buffer.from(id.keyBlob), Buffer.from(target.keyBlob)) === 0,\n    );\n    assert(match, \"Requested publicKey not found in SSH agent\");\n    return match;\n  }\n\n  if (options.fingerprint) {\n    const match = identities.find((id) => id.fingerprint === options.fingerprint);\n    assert(match, \"Requested fingerprint not found in SSH agent\");\n    return match;\n  }\n\n  // Prefer Ed25519 keys by default\n  const ed25519 = identities.find((id) => id.type === \"ssh-ed25519\");\n  return ed25519 ?? identities[0];\n}\n\nfunction decodeSshSignatureBlob(signatureBlob: Uint8Array): { algorithm: string; signature: Uint8Array } {\n  const algResult = readSshString(signatureBlob, 0);\n  const algorithm = new TextDecoder().decode(algResult.value);\n  const sigResult = readSshString(signatureBlob, algResult.nextOffset);\n  return { algorithm, signature: sigResult.value };\n}\n\nfunction sshSignatureToRaw(algorithm: string, signature: Uint8Array): Uint8Array {\n  if (algorithm === \"ssh-ed25519\") {\n    assert(signature.length === 64, \"Invalid Ed25519 signature length\");\n    return signature;\n  }\n\n  const ecdsaSizes: Record<string, number> = {\n    \"ecdsa-sha2-nistp256\": 32,\n    \"ecdsa-sha2-nistp384\": 48,\n    \"ecdsa-sha2-nistp521\": 66,\n  };\n\n  const size = ecdsaSizes[algorithm];\n  assert(size !== undefined, `Unsupported SSH signature algorithm: ${algorithm}`);\n\n  // Parse DER-encoded ECDSA signature (r, s integers)\n  const rResult = readSshString(signature, 0);\n  const sResult = readSshString(signature, rResult.nextOffset);\n  assert(sResult.nextOffset === signature.length, \"Unexpected extra bytes in signature\");\n\n  const r = stripLeadingZeros(rResult.value);\n  const s = stripLeadingZeros(sResult.value);\n  const rawR = leftPad(r, size);\n  const rawS = leftPad(s, size);\n\n  return concatBytes(rawR, rawS);\n}\n\nasync function signWithAgent(socketPath: string, identity: AgentIdentity, data: Uint8Array): Promise<Uint8Array> {\n  const payload = concatBytes(\n    writeSshString(identity.keyBlob),\n    writeSshString(data),\n    writeUint32BE(0), // flags\n  );\n\n  const response = await agentRequest(socketPath, SSH_AGENTC_SIGN_REQUEST, payload);\n\n  assert(response[0] === SSH_AGENT_SIGN_RESPONSE, `Unexpected SSH agent sign response type: ${response[0]}`);\n\n  const sigResult = readSshString(response, 1);\n  const { algorithm, signature } = decodeSshSignatureBlob(sigResult.value);\n\n  assert(algorithm === identity.type, `SSH agent signed with ${algorithm} but identity is ${identity.type}`);\n\n  return sshSignatureToRaw(algorithm, signature);\n}\n\nexport interface CreateSshAgentSignerOptions {\n  /** Override SSH agent socket (defaults to process.env.SSH_AUTH_SOCK) */\n  sshAuthSock?: string;\n  /** Select a specific key by OpenSSH public key string */\n  publicKey?: string;\n  /** Select a specific key by openagent.md fingerprint (SHA256:...) */\n  fingerprint?: string;\n  /** Optional GitHub username to include for attribution */\n  githubUser?: string;\n}\n\n/**\n * Create a signer callback compatible with UploadOptions.sign.\n */\nexport async function createSshAgentSigner(\n  options: CreateSshAgentSignerOptions = {},\n): Promise<(data: Uint8Array) => Promise<SignatureEnvelope>> {\n  const socketPath = options.sshAuthSock ?? process.env.SSH_AUTH_SOCK;\n  assert(socketPath, \"SSH_AUTH_SOCK is not set\");\n\n  const identities = await listAgentIdentities(socketPath);\n  const selected = selectIdentity(identities, options);\n\n  return async (data: Uint8Array): Promise<SignatureEnvelope> => {\n    const signatureBytes = await signWithAgent(socketPath, selected, data);\n    return {\n      sig: Buffer.from(signatureBytes).toString(\"base64\"),\n      publicKey: selected.publicKey,\n      ...(options.githubUser && { githubUser: options.githubUser }),\n    };\n  };\n}\n\n/**\n * Convenience helper for signing a single payload using the SSH agent.\n */\nexport async function createSshAgentSignatureEnvelope(\n  data: Uint8Array,\n  options: CreateSshAgentSignerOptions = {},\n): Promise<SignatureEnvelope> {\n  const signer = await createSshAgentSigner(options);\n  return await signer(data);\n}\n"]}