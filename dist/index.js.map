{"version":3,"sources":["../src/crypto.ts","../src/signing.ts","../src/client.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Cryptographic primitives for openagent.md\n *\n * AES-256-GCM encryption with HKDF key derivation.\n * Works in both Node.js (with webcrypto) and browser environments.\n *\n * Built with Claude, inspired by Coder.\n */\n\nconst SALT_BYTES = 16;\nconst IV_BYTES = 12;\nconst KEY_BYTES = 10;\nconst ID_BYTES = 4;\nconst MUTATE_KEY_BYTES = 16;\nconst BASE62 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n/**\n * Generate a random file ID (30 bits, 5 chars base62)\n */\nexport function generateId(): string {\n  const bytes = new Uint8Array(ID_BYTES);\n  crypto.getRandomValues(bytes);\n  const num = (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];\n  let result = \"\";\n  let n = num >>> 0;\n  for (let i = 0; i < 5; i++) {\n    result = BASE62[n % 62] + result;\n    n = Math.floor(n / 62);\n  }\n  return result;\n}\n\n/**\n * Generate encryption key material (80 bits, 14 chars base64url)\n */\nexport function generateKey(): string {\n  const bytes = new Uint8Array(KEY_BYTES);\n  crypto.getRandomValues(bytes);\n  return base64UrlEncode(bytes);\n}\n\n/**\n * Generate mutate key (128 bits, 22 chars base64url)\n * Used for mutation operations: delete, set expiration\n */\nexport function generateMutateKey(): string {\n  const bytes = new Uint8Array(MUTATE_KEY_BYTES);\n  crypto.getRandomValues(bytes);\n  return base64UrlEncode(bytes);\n}\n\n/**\n * Generate random salt for HKDF (128 bits)\n */\nexport function generateSalt(): Uint8Array {\n  const salt = new Uint8Array(SALT_BYTES);\n  crypto.getRandomValues(salt);\n  return salt;\n}\n\n/**\n * Generate random IV for AES-GCM (96 bits)\n */\nexport function generateIV(): Uint8Array {\n  const iv = new Uint8Array(IV_BYTES);\n  crypto.getRandomValues(iv);\n  return iv;\n}\n\n/**\n * Derive AES-256 key from key material using HKDF\n *\n * HKDF is the correct choice for deriving keys from high-entropy\n * random key material. Unlike PBKDF2, it doesn't need iterations\n * since we're not stretching a weak password.\n */\nexport async function deriveKey(keyMaterial: string, salt: Uint8Array): Promise<CryptoKey> {\n  const rawKey = base64UrlDecode(keyMaterial);\n  const baseKey = await crypto.subtle.importKey(\n    \"raw\",\n    rawKey.buffer as ArrayBuffer,\n    \"HKDF\",\n    false,\n    [\"deriveKey\"],\n  );\n  return crypto.subtle.deriveKey(\n    {\n      name: \"HKDF\",\n      salt: salt.buffer as ArrayBuffer,\n      info: new Uint8Array(0), // No additional context needed\n      hash: \"SHA-256\",\n    },\n    baseKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"],\n  );\n}\n\n/**\n * Encrypt data using AES-256-GCM\n */\nexport async function encrypt(data: Uint8Array, key: CryptoKey, iv: Uint8Array): Promise<Uint8Array> {\n  const ciphertext = await crypto.subtle.encrypt(\n    { name: \"AES-GCM\", iv: iv.buffer as ArrayBuffer },\n    key,\n    data.buffer as ArrayBuffer,\n  );\n  return new Uint8Array(ciphertext);\n}\n\n/**\n * Decrypt data using AES-256-GCM\n */\nexport async function decrypt(ciphertext: Uint8Array, key: CryptoKey, iv: Uint8Array): Promise<Uint8Array> {\n  const plaintext = await crypto.subtle.decrypt(\n    { name: \"AES-GCM\", iv: iv.buffer as ArrayBuffer },\n    key,\n    ciphertext.buffer as ArrayBuffer,\n  );\n  return new Uint8Array(plaintext);\n}\n\n/**\n * Base64url encode (URL-safe, no padding)\n */\nexport function base64UrlEncode(data: Uint8Array): string {\n  const base64 = btoa(String.fromCharCode(...data));\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\n\n/**\n * Base64url decode\n */\nexport function base64UrlDecode(str: string): Uint8Array {\n  let base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n/**\n * Standard base64 encode\n */\nexport function base64Encode(data: Uint8Array): string {\n  return btoa(String.fromCharCode(...data));\n}\n\n/**\n * Standard base64 decode\n */\nexport function base64Decode(str: string): Uint8Array {\n  const binary = atob(str);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n","/**\n * Signing and verification utilities for openagent.md\n *\n * Supports Ed25519 and ECDSA (P-256, P-384, P-521) keys in SSH format.\n *\n * Built with Claude, inspired by Coder.\n */\n\nimport { p256, p384, p521 } from \"@noble/curves/nist.js\";\nimport * as ed from \"@noble/ed25519\";\nimport { sha512 } from \"@noble/hashes/sha2.js\";\n\nimport type { SignatureEnvelope } from \"./types\";\n\n// Configure ed25519 with synchronous SHA-512\n// @ts-expect-error - sha512Sync exists at runtime but not in type defs\ned.etc.sha512Sync = (...m: Uint8Array[]) => sha512(ed.etc.concatBytes(...m));\n\n/** Supported key types */\nexport type KeyType = \"ed25519\" | \"ecdsa-p256\" | \"ecdsa-p384\" | \"ecdsa-p521\";\n\n/** Parsed public key with type and raw bytes */\nexport interface ParsedPublicKey {\n  type: KeyType;\n  keyBytes: Uint8Array;\n}\n\nconst SSH_KEY_TYPES: Record<string, KeyType> = {\n  \"ssh-ed25519\": \"ed25519\",\n  \"ecdsa-sha2-nistp256\": \"ecdsa-p256\",\n  \"ecdsa-sha2-nistp384\": \"ecdsa-p384\",\n  \"ecdsa-sha2-nistp521\": \"ecdsa-p521\",\n};\n\nfunction readSSHString(data: Uint8Array, offset: number): { value: Uint8Array; nextOffset: number } {\n  const view = new DataView(data.buffer as ArrayBuffer, data.byteOffset);\n  const len = view.getUint32(offset);\n  const value = data.slice(offset + 4, offset + 4 + len);\n  return { value, nextOffset: offset + 4 + len };\n}\n\nfunction base64DecodeInternal(str: string): Uint8Array {\n  let base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n/**\n * Parse an SSH public key and extract the key bytes and type.\n * Supports formats:\n * - ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... [comment]\n * - ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTY... [comment]\n * - ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQ... [comment]\n * - ecdsa-sha2-nistp521 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjE... [comment]\n * - Raw base64 (32 bytes when decoded = Ed25519)\n */\nexport function parsePublicKey(keyString: string): ParsedPublicKey {\n  const trimmed = keyString.trim();\n\n  for (const [sshType, keyType] of Object.entries(SSH_KEY_TYPES)) {\n    if (trimmed.startsWith(`${sshType} `)) {\n      const parts = trimmed.split(\" \");\n      if (parts.length < 2) {\n        throw new Error(\"Invalid SSH key format\");\n      }\n\n      const keyData = base64DecodeInternal(parts[1]);\n      const { value: typeBytes, nextOffset: afterType } = readSSHString(keyData, 0);\n      const typeStr = new TextDecoder().decode(typeBytes);\n\n      if (typeStr !== sshType) {\n        throw new Error(`Key type mismatch: expected ${sshType}, got ${typeStr}`);\n      }\n\n      if (keyType === \"ed25519\") {\n        const { value: rawKey } = readSSHString(keyData, afterType);\n        if (rawKey.length !== 32) {\n          throw new Error(\"Invalid Ed25519 key length\");\n        }\n        return { type: \"ed25519\", keyBytes: rawKey };\n      }\n\n      // ECDSA: skip curve name, read point\n      const { nextOffset: afterCurve } = readSSHString(keyData, afterType);\n      const { value: point } = readSSHString(keyData, afterCurve);\n      return { type: keyType, keyBytes: point };\n    }\n  }\n\n  // Fallback: try raw base64 (Ed25519)\n  const decoded = base64DecodeInternal(trimmed);\n  if (decoded.length === 32) {\n    return { type: \"ed25519\", keyBytes: decoded };\n  }\n\n  throw new Error(\"Unsupported public key format\");\n}\n\n/**\n * Sign a message with Ed25519 private key.\n * @param message - The message bytes to sign\n * @param privateKey - 32-byte Ed25519 private key\n * @returns Base64-encoded signature (64 bytes)\n */\nexport async function signEd25519(message: Uint8Array, privateKey: Uint8Array): Promise<string> {\n  const sig = await ed.signAsync(message, privateKey);\n  return btoa(String.fromCharCode(...sig));\n}\n\n/**\n * Sign a message with ECDSA private key (P-256/384/521).\n * @param message - The message bytes to sign (will be hashed)\n * @param privateKey - ECDSA private key bytes\n * @param curve - Which curve to use\n * @returns Base64-encoded signature\n */\nexport function signECDSA(message: Uint8Array, privateKey: Uint8Array, curve: \"p256\" | \"p384\" | \"p521\"): string {\n  const curves = { p256, p384, p521 };\n  const sigBytes = curves[curve].sign(message, privateKey, { prehash: true });\n  return btoa(String.fromCharCode(...sigBytes));\n}\n\n/**\n * Helper: Create a SignatureEnvelope from content + private key.\n * This is the high-level API for signing before upload.\n *\n * @param content - The content bytes to sign\n * @param privateKey - Private key bytes (32 bytes for Ed25519, variable for ECDSA)\n * @param publicKey - SSH format public key string (e.g., \"ssh-ed25519 AAAA...\")\n * @param options - Optional GitHub username for attribution\n * @returns SignatureEnvelope ready for upload\n */\nexport async function createSignatureEnvelope(\n  content: Uint8Array,\n  privateKey: Uint8Array,\n  publicKey: string,\n  options?: { githubUser?: string },\n): Promise<SignatureEnvelope> {\n  const parsed = parsePublicKey(publicKey);\n  let sig: string;\n\n  if (parsed.type === \"ed25519\") {\n    sig = await signEd25519(content, privateKey);\n  } else {\n    const curve = parsed.type.replace(\"ecdsa-\", \"\") as \"p256\" | \"p384\" | \"p521\";\n    sig = signECDSA(content, privateKey, curve);\n  }\n\n  return {\n    sig,\n    publicKey,\n    githubUser: options?.githubUser,\n  };\n}\n\n/**\n * Verify a signature using the appropriate algorithm based on key type.\n * For Ed25519: signature is raw 64 bytes\n * For ECDSA: signature is DER-encoded or raw r||s format\n *\n * @param parsedKey - Parsed public key (from parsePublicKey)\n * @param message - Original message bytes\n * @param signature - Signature bytes (not base64)\n * @returns true if signature is valid\n */\nexport async function verifySignature(\n  parsedKey: ParsedPublicKey,\n  message: Uint8Array,\n  signature: Uint8Array,\n): Promise<boolean> {\n  try {\n    switch (parsedKey.type) {\n      case \"ed25519\":\n        return await ed.verifyAsync(signature, message, parsedKey.keyBytes);\n      case \"ecdsa-p256\":\n        return p256.verify(signature, message, parsedKey.keyBytes, { prehash: true });\n      case \"ecdsa-p384\":\n        return p384.verify(signature, message, parsedKey.keyBytes, { prehash: true });\n      case \"ecdsa-p521\":\n        return p521.verify(signature, message, parsedKey.keyBytes, { prehash: true });\n      default:\n        return false;\n    }\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Compute SHA256 fingerprint of a public key (matches ssh-keygen -l format)\n * @param publicKey - Raw public key bytes\n * @returns Fingerprint string like \"SHA256:abc123...\"\n */\nexport async function computeFingerprint(publicKey: Uint8Array): Promise<string> {\n  const hash = await crypto.subtle.digest(\"SHA-256\", publicKey.buffer as ArrayBuffer);\n  const hashArray = new Uint8Array(hash);\n  const base64 = btoa(String.fromCharCode(...hashArray));\n  return `SHA256:${base64.replace(/=+$/, \"\")}`;\n}\n\n/**\n * Format a fingerprint for nice display.\n * Converts base64 fingerprint to uppercase hex groups like \"DEAD BEEF 1234 5678\"\n */\nexport function formatFingerprint(fingerprint: string): string {\n  const base64Part = fingerprint.startsWith(\"SHA256:\") ? fingerprint.slice(7) : fingerprint;\n  try {\n    const binary = atob(base64Part);\n    const hex = Array.from(binary)\n      .map((c) => c.charCodeAt(0).toString(16).padStart(2, \"0\"))\n      .join(\"\")\n      .toUpperCase();\n    const short = hex.slice(0, 16);\n    return short.match(/.{4}/g)?.join(\" \") || short;\n  } catch {\n    return fingerprint.slice(0, 16).toUpperCase();\n  }\n}\n","/**\n * openagent.md Client Library\n *\n * Reference implementation for encrypting, uploading, downloading, and decrypting files.\n * Works in both Node.js (with webcrypto) and browser environments.\n *\n * Built with Claude, inspired by Coder.\n */\n\nimport {\n  base64Decode,\n  base64Encode,\n  decrypt,\n  deriveKey,\n  encrypt,\n  generateIV,\n  generateKey,\n  generateSalt,\n} from \"./crypto\";\nimport { createSignatureEnvelope } from \"./signing\";\nimport type { FileInfo, SignatureEnvelope, SignedPayload } from \"./types\";\n\nconst DEFAULT_BASE_URL = \"https://openagent.md\";\n\nfunction assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction bytesEqual(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.byteLength !== b.byteLength) return false;\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction decodeUtf8Strict(data: Uint8Array): string {\n  try {\n    const decoded = new TextDecoder(\"utf-8\", {\n      fatal: true,\n      ignoreBOM: true,\n    }).decode(data);\n    const reencoded = new TextEncoder().encode(decoded);\n    assert(bytesEqual(data, reencoded), \"Signed uploads require UTF-8 text content\");\n    return decoded;\n  } catch (error) {\n    if (error instanceof Error && error.message === \"Signed uploads require UTF-8 text content\") {\n      throw error;\n    }\n    throw new Error(\"Signed uploads require UTF-8 text content\");\n  }\n}\n\nfunction assertSignatureEnvelope(value: unknown): asserts value is SignatureEnvelope {\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\"Invalid SignatureEnvelope\");\n  }\n  const env = value as SignatureEnvelope;\n  if (typeof env.sig !== \"string\" || env.sig.length === 0) {\n    throw new Error(\"Invalid SignatureEnvelope.sig\");\n  }\n  if (typeof env.publicKey !== \"string\" || env.publicKey.length === 0) {\n    throw new Error(\"Invalid SignatureEnvelope.publicKey\");\n  }\n  if (env.githubUser !== undefined && typeof env.githubUser !== \"string\") {\n    throw new Error(\"Invalid SignatureEnvelope.githubUser\");\n  }\n}\n\n/** Options for signing content during upload */\nexport type SignOptions =\n  | {\n      /** Private key bytes (32 bytes for Ed25519, variable for ECDSA) */\n      privateKey: Uint8Array;\n      /** SSH format public key string (e.g., \"ssh-ed25519 AAAA...\") */\n      publicKey: string;\n      /** Optional GitHub username for attribution */\n      githubUser?: string;\n    }\n  | {\n      /**\n       * Custom signer function.\n       * Useful when the private key lives outside this process (e.g., an SSH agent).\n       */\n      signer: (data: Uint8Array) => Promise<SignatureEnvelope>;\n    };\n\nexport interface UploadOptions {\n  /** Base URL of the openagent.md service */\n  baseUrl?: string;\n  /** Expiration time (unix timestamp ms, ISO date string, or Date object) */\n  expiresAt?: number | string | Date;\n  /**\n   * Precomputed signature envelope to embed in the encrypted payload.\n   * Takes precedence over `sign`.\n   */\n  signature?: SignatureEnvelope;\n  /**\n   * Sign the content.\n   *\n   * When provided, the decrypted blob becomes JSON (SignedPayload) containing both\n   * the content string and the signature envelope.\n   */\n  sign?: SignOptions;\n}\n\nexport interface UploadResult {\n  /** Full URL with encryption key in fragment */\n  url: string;\n  /** File ID (without key) */\n  id: string;\n  /** Encryption key (base64url) */\n  key: string;\n  /** Mutate key (base64url) - store this to mutate (delete, change expiration) the file later */\n  mutateKey: string;\n  /** Expiration timestamp (ms), if set */\n  expiresAt?: number;\n}\n\nexport interface DownloadResult {\n  /** Decrypted file content */\n  data: Uint8Array;\n  /** Original file info (name, type, size) */\n  info: FileInfo;\n  /** Decrypted signature envelope (if present) */\n  signature?: SignatureEnvelope;\n}\n\n/**\n * Encrypt and upload a file to openagent.md\n *\n * @param data - File contents as Uint8Array\n * @param fileInfo - Original file metadata (name, type, size)\n * @param options - Upload options (including optional signature)\n * @returns Upload result with URL containing encryption key\n */\nexport async function upload(\n  data: Uint8Array,\n  fileInfo: FileInfo,\n  options: UploadOptions = {},\n): Promise<UploadResult> {\n  const baseUrl = options.baseUrl ?? DEFAULT_BASE_URL;\n  const keyMaterial = generateKey();\n  const salt = generateSalt();\n  const iv = generateIV();\n  const cryptoKey = await deriveKey(keyMaterial, salt);\n\n  const wantsSignature = options.signature !== undefined || options.sign !== undefined;\n  const signedContent = wantsSignature ? decodeUtf8Strict(data) : undefined;\n\n  let signatureEnvelope: SignatureEnvelope | undefined;\n\n  if (options.signature !== undefined) {\n    assertSignatureEnvelope(options.signature);\n    signatureEnvelope = options.signature;\n  } else if (options.sign) {\n    if (\"signer\" in options.sign) {\n      const envelope = await options.sign.signer(data);\n      assertSignatureEnvelope(envelope);\n      signatureEnvelope = envelope;\n    } else {\n      signatureEnvelope = await createSignatureEnvelope(data, options.sign.privateKey, options.sign.publicKey, {\n        githubUser: options.sign.githubUser,\n      });\n      assertSignatureEnvelope(signatureEnvelope);\n    }\n  }\n\n  if (wantsSignature) {\n    assert(signatureEnvelope !== undefined, \"Signature requested but no signature envelope was produced\");\n  }\n\n  let plaintext: Uint8Array;\n  if (signatureEnvelope) {\n    assert(signedContent !== undefined, \"Signed content string missing\");\n    const signed: SignedPayload = {\n      content: signedContent,\n      sig: signatureEnvelope,\n    };\n    plaintext = new TextEncoder().encode(JSON.stringify(signed));\n  } else {\n    plaintext = data;\n  }\n\n  const payload = await encrypt(plaintext, cryptoKey, iv);\n\n  // Encrypt file metadata separately\n  const metaJson = JSON.stringify(fileInfo);\n  const metaBytes = new TextEncoder().encode(metaJson);\n  const metaIv = generateIV();\n  const encryptedMeta = await encrypt(metaBytes, cryptoKey, metaIv);\n\n  const uploadMeta = {\n    salt: base64Encode(salt),\n    iv: base64Encode(iv),\n    encryptedMeta: base64Encode(new Uint8Array([...metaIv, ...encryptedMeta])),\n  };\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/octet-stream\",\n    \"X-Lattice-Meta\": btoa(JSON.stringify(uploadMeta)),\n  };\n\n  if (options.expiresAt !== undefined) {\n    let expiresDate: Date;\n    if (options.expiresAt instanceof Date) {\n      expiresDate = options.expiresAt;\n    } else if (typeof options.expiresAt === \"string\") {\n      expiresDate = new Date(options.expiresAt);\n    } else {\n      expiresDate = new Date(options.expiresAt);\n    }\n    headers[\"X-Lattice-Expires\"] = expiresDate.toISOString();\n  }\n\n  const response = await fetch(`${baseUrl}/`, {\n    method: \"POST\",\n    headers,\n    body: payload.buffer as ArrayBuffer,\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: \"Upload failed\" }));\n    throw new Error(error.error || \"Upload failed\");\n  }\n\n  const result = await response.json();\n  return {\n    url: `${baseUrl}/${result.id}#${keyMaterial}`,\n    id: result.id,\n    key: keyMaterial,\n    mutateKey: result.mutateKey,\n    ...(result.expiresAt && { expiresAt: result.expiresAt }),\n  };\n}\n\n/**\n * Download and decrypt a file from openagent.md\n *\n * @param url - Full URL with encryption key in fragment, or just the ID\n * @param key - Encryption key (required if url doesn't contain fragment)\n * @param options - Download options\n * @returns Decrypted file data and metadata\n */\nexport async function download(\n  url: string,\n  key?: string,\n  options: { baseUrl?: string } = {},\n): Promise<DownloadResult> {\n  const baseUrl = options.baseUrl ?? DEFAULT_BASE_URL;\n  let id: string;\n  let keyMaterial: string;\n\n  if (url.includes(\"#\")) {\n    const urlObj = new URL(url);\n    id = urlObj.pathname.slice(1);\n    keyMaterial = urlObj.hash.slice(1);\n  } else if (url.includes(\"/\")) {\n    const parts = url.split(\"/\");\n    id = parts[parts.length - 1];\n    if (!key) throw new Error(\"Key required when URL has no fragment\");\n    keyMaterial = key;\n  } else {\n    id = url;\n    if (!key) throw new Error(\"Key required when only ID is provided\");\n    keyMaterial = key;\n  }\n\n  const response = await fetch(`${baseUrl}/${id}`);\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: \"Download failed\" }));\n    throw new Error(error.error || \"Download failed\");\n  }\n\n  const metaHeader = response.headers.get(\"X-Lattice-Meta\");\n  if (!metaHeader) {\n    throw new Error(\"Missing metadata header\");\n  }\n\n  const uploadMeta = JSON.parse(atob(metaHeader));\n  const encryptedData = new Uint8Array(await response.arrayBuffer());\n\n  const salt = base64Decode(uploadMeta.salt);\n  const iv = base64Decode(uploadMeta.iv);\n  const cryptoKey = await deriveKey(keyMaterial, salt);\n\n  // Decrypt file metadata\n  const encryptedMetaWithIv = base64Decode(uploadMeta.encryptedMeta);\n  const metaIv = encryptedMetaWithIv.slice(0, 12);\n  const encryptedMetaData = encryptedMetaWithIv.slice(12);\n  const metaBytes = await decrypt(encryptedMetaData, cryptoKey, metaIv);\n  const info: FileInfo = JSON.parse(new TextDecoder().decode(metaBytes));\n\n  // Decrypt file content\n  const decrypted = await decrypt(encryptedData, cryptoKey, iv);\n\n  // Check if content is a signed payload (JSON starting with '{')\n  if (decrypted[0] === 123) {\n    try {\n      const jsonStr = new TextDecoder().decode(decrypted);\n      const parsed = JSON.parse(jsonStr) as SignedPayload;\n      if (typeof parsed.content === \"string\" && parsed.sig) {\n        const data = new TextEncoder().encode(parsed.content);\n        const signature = parsed.sig;\n        return { data, info, signature };\n      }\n    } catch {\n      // Not valid JSON, treat as raw content\n    }\n  }\n\n  return { data: decrypted, info };\n}\n\n/**\n * Get file metadata without downloading the full file\n *\n * @param url - Full URL or ID\n * @param key - Encryption key (required to decrypt metadata)\n * @param options - Request options\n * @returns Decrypted file info and server metadata\n */\nexport async function getMeta(\n  url: string,\n  key?: string,\n  options: { baseUrl?: string } = {},\n): Promise<{ info: FileInfo; size: number }> {\n  const baseUrl = options.baseUrl ?? DEFAULT_BASE_URL;\n  let id: string;\n  let keyMaterial: string;\n\n  if (url.includes(\"#\")) {\n    const urlObj = new URL(url);\n    id = urlObj.pathname.slice(1);\n    keyMaterial = urlObj.hash.slice(1);\n  } else if (url.includes(\"/\")) {\n    const parts = url.split(\"/\");\n    id = parts[parts.length - 1];\n    if (!key) throw new Error(\"Key required when URL has no fragment\");\n    keyMaterial = key;\n  } else {\n    id = url;\n    if (!key) throw new Error(\"Key required when only ID is provided\");\n    keyMaterial = key;\n  }\n\n  const response = await fetch(`${baseUrl}/${id}/meta`);\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: \"Request failed\" }));\n    throw new Error(error.error || \"Request failed\");\n  }\n\n  const meta = await response.json();\n  const salt = base64Decode(meta.salt);\n  const cryptoKey = await deriveKey(keyMaterial, salt);\n\n  const encryptedMetaWithIv = base64Decode(meta.encryptedMeta);\n  const metaIv = encryptedMetaWithIv.slice(0, 12);\n  const encryptedMetaData = encryptedMetaWithIv.slice(12);\n  const metaBytes = await decrypt(encryptedMetaData, cryptoKey, metaIv);\n  const info: FileInfo = JSON.parse(new TextDecoder().decode(metaBytes));\n\n  return { info, size: meta.size };\n}\n\n/**\n * Parse an openagent.md URL into its components\n */\nexport function parseUrl(url: string): { id: string; key: string } | null {\n  try {\n    const urlObj = new URL(url);\n    if (!urlObj.hash) return null;\n    const id = urlObj.pathname.slice(1);\n    const key = urlObj.hash.slice(1);\n    if (!id || !key) return null;\n    return { id, key };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build an openagent.md URL from components\n */\nexport function buildUrl(id: string, key: string, baseUrl: string = DEFAULT_BASE_URL): string {\n  return `${baseUrl}/${id}#${key}`;\n}\n\n/**\n * Delete a file from openagent.md using its mutate key\n *\n * @param id - File ID\n * @param mutateKey - Mutate key returned from upload\n * @param options - Request options\n */\nexport async function deleteFile(\n  id: string,\n  mutateKey: string,\n  options: { baseUrl?: string } = {},\n): Promise<void> {\n  const baseUrl = options.baseUrl ?? DEFAULT_BASE_URL;\n  const response = await fetch(`${baseUrl}/${id}`, {\n    method: \"DELETE\",\n    headers: {\n      \"X-Lattice-Mutate-Key\": mutateKey,\n    },\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: \"Delete failed\" }));\n    throw new Error(error.error || \"Delete failed\");\n  }\n}\n\nexport interface SetExpirationOptions {\n  /** Base URL of the openagent.md service */\n  baseUrl?: string;\n}\n\nexport interface SetExpirationResult {\n  /** Whether the operation succeeded */\n  success: boolean;\n  /** File ID */\n  id: string;\n  /** New expiration timestamp (ms), or undefined if expiration was removed */\n  expiresAt?: number;\n}\n\n/**\n * Set or remove the expiration of a file using its mutate key\n *\n * @param id - File ID\n * @param mutateKey - Mutate key returned from upload\n * @param expiresAt - New expiration time (unix timestamp ms, ISO date string, Date object, or \"never\" to remove expiration)\n * @param options - Request options\n * @returns Result with new expiration info\n */\nexport async function setExpiration(\n  id: string,\n  mutateKey: string,\n  expiresAt: number | string | Date | \"never\",\n  options: SetExpirationOptions = {},\n): Promise<SetExpirationResult> {\n  const baseUrl = options.baseUrl ?? DEFAULT_BASE_URL;\n\n  let expiresHeader: string;\n  if (expiresAt === \"never\") {\n    expiresHeader = \"never\";\n  } else if (expiresAt instanceof Date) {\n    expiresHeader = expiresAt.toISOString();\n  } else if (typeof expiresAt === \"string\") {\n    expiresHeader = new Date(expiresAt).toISOString();\n  } else {\n    expiresHeader = new Date(expiresAt).toISOString();\n  }\n\n  const response = await fetch(`${baseUrl}/${id}`, {\n    method: \"PATCH\",\n    headers: {\n      \"X-Lattice-Mutate-Key\": mutateKey,\n      \"X-Lattice-Expires\": expiresHeader,\n    },\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: \"Set expiration failed\" }));\n    throw new Error(error.error || \"Set expiration failed\");\n  }\n\n  return response.json();\n}\n"]}